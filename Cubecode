import board
import time
import pwmio
import math

MAX_DUTY_CYCLE = 65535
rate = 100000
period = 1

#sets pwm mode
x_pwm = pwmio.PWMOut(board.GP0, duty_cycle = 0, frequency = rate)
y_pwm = pwmio.PWMOut(board.GP1, duty_cycle = 0, frequency = rate)

#scales size of the cube
scaling_factor = 0.75

vertices = [
    (-1 * scaling_factor, -1 * scaling_factor, -1 * scaling_factor),
    (1 * scaling_factor, -1 * scaling_factor, -1 * scaling_factor),
    (1 * scaling_factor, 1 * scaling_factor, -1 * scaling_factor),
    (-1 * scaling_factor, 1 * scaling_factor, -1 * scaling_factor),
    (-1 * scaling_factor, -1 * scaling_factor, 1 * scaling_factor),
    (1 * scaling_factor, -1 * scaling_factor, 1 * scaling_factor),
    (1 * scaling_factor, 1 * scaling_factor, 1 * scaling_factor),
    (-1 * scaling_factor, 1 * scaling_factor, 1 * scaling_factor)
]

edges = [
    (0, 1), (1, 2), (2, 3), (3, 0),
    (4, 5), (5, 6), (6, 7), (7, 4),
    (0, 4), (1, 5), (2, 6), (3, 7)
]

#returns the new x, y, z
def rotate(vertex, angle):
    x, y, z = vertex
    #setting a variable for sin and cosine made a distinguishable difference in speed
    sin_angle = math.sin(angle)
    cos_angle = math.cos(angle)
    #matrix multiplication that only my roommate fully understands
    x2 = x * cos_angle - z * sin_angle
    z2 = x * sin_angle + z * cos_angle

    y2 = y * cos_angle - z2 * sin_angle
    z3 = y * sin_angle + z2 * cos_angle

    return (x2, y2, z3)

#returns the flat projection of the 3d object
def project(vertex, viewer_distance=10):
    x, y, z = vertex
    factor = viewer_distance / (viewer_distance - z)
    x_proj = x * factor
    y_proj = y * factor
    return (x_proj, y_proj)

#voltage to necessary duty cycle for pwm
def voltage_to_duty_cycle(voltage):
    return int((voltage / 3.3) * MAX_DUTY_CYCLE)

angle = 0.0
while True:
    #increments angle, can be sped up with larger steps
    angle += 0.01
    for edge in edges:
        v1_proj = project(rotate(vertices[edge[0]], angle))
        v2_proj = project(rotate(vertices[edge[1]], angle))

        for t in range(101):
            t = t / 100
            #interpolates between vertices to make smooth edge
            x_val = (1 - t) * v1_proj[0] + t * v2_proj[0]
            y_val = (1 - t) * v1_proj[1] + t * v2_proj[1]
            #shifts cube up and to the right
            x_voltage = x_val + 1.65
            y_voltage = y_val + 1.65
            x_pwm.duty_cycle = voltage_to_duty_cycle(x_voltage)
            y_pwm.duty_cycle = voltage_to_duty_cycle(y_voltage)

